#!/usr/bin/env bash
# ci-scripts/lint.sh
#
# Wrapper to run linters locally or in CI for the finassist project.
# Supports Python (black, isort, flake8, mypy), JS/CSS (eslint, stylelint),
# markdown (markdownlint), and Dockerfiles (hadolint).
#
# Usage:
#   ./ci-scripts/lint.sh             # run a sensible default set of linters
#   ./ci-scripts/lint.sh --all       # run everything
#   ./ci-scripts/lint.sh --python    # python only
#   ./ci-scripts/lint.sh --js        # eslint only
#   ./ci-scripts/lint.sh --fix       # attempt to auto-fix where supported (black/isort/eslint/stylelint)
#   ./ci-scripts/lint.sh --ci        # stricter (set -e), fail fast
#
# CI tip: call with --ci --all --fix (if you want formatting applied automatically before failing)
#
set -o pipefail

# Colors
RED=$(printf '\033[31m')
YELLOW=$(printf '\033[33m')
GREEN=$(printf '\033[32m')
BLUE=$(printf '\033[34m')
BOLD=$(printf '\033[1m')
RESET=$(printf '\033[0m')

# Defaults - adjust to your repo layout if needed
PY_PATHS=("backend" "ml_service" "tests")
JS_PATHS=("backend/templates/static" "backend/assets" "ml_service")
CSS_GLOB="backend/templates/static/**/*.css backend/assets/**/*.css"
MD_GLOB="README.md docs/**/*.md backend/**/*.md"
DOCKERFILES_GLOB="**/Dockerfile infra/**/*.Dockerfile"
# files to exclude from some linters (e.g. autogenerated)
EXCLUDE_PATTERNS=()

# Flags (modified by args)
RUN_PY=false
RUN_JS=false
RUN_CSS=false
RUN_MD=false
RUN_DOCKER=false
RUN_ALL=false
FIX=false
CI_MODE=false

FAILURES=0

usage() {
  cat <<EOF
Usage: $0 [options]

Options:
  --all        Run all linters (python, js, css, markdown, docker)
  --python     Run python linters (black, isort, flake8, mypy)
  --js         Run javascript linters (eslint)
  --css        Run css linters (stylelint)
  --markdown   Run markdown lint (markdownlint)
  --docker     Run hadolint on Dockerfiles
  --fix        Attempt to auto-fix where supported (black/isort/eslint/stylelint)
  --ci         CI mode (fail on first error, stricter exit code)
  -h, --help   Show this help
EOF
  exit 2
}

# Parse args
if [ $# -eq 0 ]; then
  # sensible default: run python + js + css + markdown
  RUN_PY=true
  RUN_JS=true
  RUN_CSS=true
  RUN_MD=true
else
  while [ $# -gt 0 ]; do
    case "$1" in
      --all) RUN_ALL=true; RUN_PY=true; RUN_JS=true; RUN_CSS=true; RUN_MD=true; RUN_DOCKER=true; shift ;;
      --python) RUN_PY=true; shift ;;
      --js) RUN_JS=true; shift ;;
      --css) RUN_CSS=true; shift ;;
      --markdown) RUN_MD=true; shift ;;
      --docker) RUN_DOCKER=true; shift ;;
      --fix) FIX=true; shift ;;
      --ci) CI_MODE=true; shift ;;
      -h|--help) usage ;;
      *) echo "${YELLOW}Unknown option: $1${RESET}"; usage ;;
    esac
  done
fi

if [ "$RUN_ALL" = true ]; then
  RUN_PY=true; RUN_JS=true; RUN_CSS=true; RUN_MD=true; RUN_DOCKER=true
fi

# Utility: check command exists
command_exists() {
  command -v "$1" >/dev/null 2>&1
}

# Utility: run a check and count failures
run_cmd() {
  local cmd="$*"
  echo "${BLUE}${BOLD}>>> $cmd${RESET}"
  if eval "$cmd"; then
    echo "${GREEN}OK${RESET}"
    return 0
  else
    echo "${RED}FAILED: $cmd${RESET}"
    FAILURES=$((FAILURES + 1))
    if [ "$CI_MODE" = true ]; then
      echo "${RED}CI mode: exiting on first failure.${RESET}"
      exit 1
    fi
    return 1
  fi
}

# ---------- Python linters ----------
run_python_linters() {
  echo "${BOLD}Running Python linters...${RESET}"

  # collect python paths that actually exist
  local paths=()
  for p in "${PY_PATHS[@]}"; do
    if [ -e "$p" ]; then
      paths+=("$p")
    fi
  done
  if [ ${#paths[@]} -eq 0 ]; then
    echo "${YELLOW}No Python paths found; skipping Python linters.${RESET}"
    return
  fi
  local joined_paths="${paths[*]}"

  # isort
  if command_exists isort; then
    if [ "$FIX" = true ]; then
      run_cmd "isort ${joined_paths}"
    else
      run_cmd "isort --check-only --diff ${joined_paths}"
    fi
  else
    echo "${YELLOW}isort not found; install via 'pip install isort'${RESET}"
  fi

  # black
  if command_exists black; then
    if [ "$FIX" = true ]; then
      run_cmd "black ${joined_paths}"
    else
      run_cmd "black --check ${joined_paths}"
    fi
  else
    echo "${YELLOW}black not found; install via 'pip install black'${RESET}"
  fi

  # flake8
  if command_exists flake8; then
    run_cmd "flake8 ${joined_paths}"
  else
    echo "${YELLOW}flake8 not found; install via 'pip install flake8'${RESET}"
  fi

  # mypy (optional)
  if command_exists mypy; then
    # target modules only (avoid scanning entire site-packages)
    # assume backend and ml_service are python packages / modules
    local mypy_targets=()
    for p in "${paths[@]}"; do
      if [ -d "$p" ]; then
        mypy_targets+=("$p")
      fi
    done
    run_cmd "mypy ${mypy_targets[*]:-}"
  else
    echo "${YELLOW}mypy not found; install via 'pip install mypy' (optional)${RESET}"
  fi
}

# ---------- JS linters ----------
run_js_linters() {
  echo "${BOLD}Running JS/TS linters...${RESET}"

  # find directories with package.json or js files
  local js_targets=()
  for p in "${JS_PATHS[@]}"; do
    if [ -d "$p" ]; then
      js_targets+=("$p")
    fi
  done

  # fallback: search for JS/TS files
  if [ ${#js_targets[@]} -eq 0 ]; then
    mapfile -t js_targets < <(git ls-files -- '**/*.js' '**/*.ts' 2>/dev/null || true)
  fi

  if [ ${#js_targets[@]} -eq 0 ]; then
    echo "${YELLOW}No JS/TS targets found; skipping eslint.${RESET}"
    return
  fi

  if command_exists npx; then
    if command_exists eslint; then
      ESLINT_CMD="eslint"
    else
      ESLINT_CMD="npx eslint"
    fi

    # eslint run
    if [ "$FIX" = true ]; then
      run_cmd "${ESLINT_CMD} ${js_targets[*]} --ext .js,.jsx,.ts,.tsx --fix"
    else
      run_cmd "${ESLINT_CMD} ${js_targets[*]} --ext .js,.jsx,.ts,.tsx"
    fi
  else
    echo "${YELLOW}npx not found; install Node.js/npm or run eslint manually.${RESET}"
  fi
}

# ---------- CSS linters ----------
run_css_linters() {
  echo "${BOLD}Running CSS linters...${RESET}"

  # stylelint via npx or stylelint
  if command_exists npx; then
    STYLELINT_CMD="npx stylelint"
  elif command_exists stylelint; then
    STYLELINT_CMD="stylelint"
  else
    STYLELINT_CMD=""
  fi

  if [ -z "$STYLELINT_CMD" ]; then
    echo "${YELLOW}stylelint (or npx) not found; skipping CSS linting.${RESET}"
    return
  fi

  # run stylelint over css glob
  if [ "$FIX" = true ]; then
    run_cmd "${STYLELINT_CMD} ${CSS_GLOB} --fix || true"
    # stylelint may return non-zero even after fixes; check again
    run_cmd "${STYLELINT_CMD} ${CSS_GLOB}"
  else
    run_cmd "${STYLELINT_CMD} ${CSS_GLOB}"
  fi
}

# ---------- Markdown linter ----------
run_md_linter() {
  echo "${BOLD}Running Markdown lint...${RESET}"

  if command_exists npx; then
    MD_CMD="npx markdownlint-cli"
  elif command_exists markdownlint; then
    MD_CMD="markdownlint"
  else
    MD_CMD=""
  fi

  if [ -z "$MD_CMD" ]; then
    echo "${YELLOW}markdownlint (or npx) not found; skipping markdown lint.${RESET}"
    return
  fi

  run_cmd "${MD_CMD} ${MD_GLOB}"
}

# ---------- Dockerfile linter ----------
run_docker_linter() {
  echo "${BOLD}Running Dockerfile lint (hadolint)...${RESET}"

  # collect Dockerfiles (git-aware)
  mapfile -t dockerfiles < <(git ls-files -- ${DOCKERFILES_GLOB} 2>/dev/null || true)
  # fallback: find
  if [ ${#dockerfiles[@]} -eq 0 ]; then
    mapfile -t dockerfiles < <(find . -type f -iname Dockerfile -o -iname '*Dockerfile' 2>/dev/null || true)
  fi

  if [ ${#dockerfiles[@]} -eq 0 ]; then
    echo "${YELLOW}No Dockerfiles found; skipping hadolint.${RESET}"
    return
  fi

  if command_exists hadolint; then
    for df in "${dockerfiles[@]}"; do
      run_cmd "hadolint ${df}"
    done
  elif command_exists docker; then
    # fallback to hadolint Docker image
    for df in "${dockerfiles[@]}"; do
      echo "${BLUE}Using hadolint Docker image to lint ${df}${RESET}"
      if docker run --rm -i hadolint/hadolint < "${df}"; then
        echo "${GREEN}hadolint OK for ${df}${RESET}"
      else
        echo "${RED}hadolint FAILED for ${df}${RESET}"
        FAILURES=$((FAILURES + 1))
        if [ "$CI_MODE" = true ]; then
          exit 1
        fi
      fi
    done
  else
    echo "${YELLOW}hadolint not found and docker unavailable; skipping Dockerfile lint.${RESET}"
  fi
}

# ---------- Run chosen linters ----------
main() {
  echo "${BOLD}Lint wrapper - starting${RESET}"
  echo "Fix mode: ${FIX}, CI mode: ${CI_MODE}"

  if [ "$RUN_PY" = true ]; then
    run_python_linters
  fi

  if [ "$RUN_JS" = true ]; then
    run_js_linters
  fi

  if [ "$RUN_CSS" = true ]; then
    run_css_linters
  fi

  if [ "$RUN_MD" = true ]; then
    run_md_linter
  fi

  if [ "$RUN_DOCKER" = true ]; then
    run_docker_linter
  fi

  if [ "$FAILURES" -eq 0 ]; then
    echo "${GREEN}${BOLD}All linters passed.${RESET}"
    exit 0
  else
    echo "${RED}${BOLD}Linters reported ${FAILURES} failure(s).${RESET}"
    exit "${FAILURES}"
  fi
}

main "$@"
